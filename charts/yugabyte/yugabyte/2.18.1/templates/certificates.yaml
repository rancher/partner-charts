{{- $root := . -}}
---
{{- if $root.Values.tls.certManager.enabled }}
{{- if $root.Values.tls.certManager.bootstrapSelfsigned }}
---
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name:  {{ (printf "%s-bootstrap" (include "yugabyte.tls_cm_issuer" $root)) | quote }}
  namespace: "{{ $root.Release.Namespace }}"
spec:
  selfSigned: {}
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: {{ $root.Values.oldNamingStyle | ternary "yugabyte-ca" (printf "%s-ca" (include "yugabyte.fullname" $root)) }}
  namespace: "{{ $root.Release.Namespace }}"
spec:
  isCA: true
  privateKey:
    algorithm: {{ $root.Values.tls.certManager.certificates.algorithm | quote }}
    encoding: PKCS8
    size: {{ $root.Values.tls.certManager.certificates.keySize }}
  commonName: Yugabyte Selfsigned CA
  secretName: {{ $root.Values.oldNamingStyle | ternary "yugabyte-ca" (printf "%s-ca" (include "yugabyte.fullname" $root)) }}
  issuerRef:
    name: {{ (printf "%s-bootstrap" (include "yugabyte.tls_cm_issuer" $root)) | quote }}
    kind: Issuer
---
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: {{ include "yugabyte.tls_cm_issuer" $root | quote }}
  namespace: "{{ $root.Release.Namespace }}"
spec:
  ca:
    secretName: {{ $root.Values.oldNamingStyle | ternary "yugabyte-ca" (printf "%s-ca" (include "yugabyte.fullname" $root)) }}
---
{{- else }}
{{/* when bootstrapSelfsigned = false, ie. when using an external CA.
Create a Secret with just the rootCA.cert value and mount into master/tserver pods.
This will be used as a fall back in case the Secret generated by cert-manager does not
have a root ca.crt. This can happen for certain certificate issuers like LetsEncrypt.
*/}}
---
apiVersion: v1
kind: Secret
metadata:
  name: {{ printf "%s-root-ca" (include "yugabyte.fullname" $root) }}
  namespace: "{{ $root.Release.Namespace }}"
  labels:
    {{- include "yugabyte.labels" $root | indent 4 }}
type: Opaque
data:
  ca.crt: {{ $root.Values.tls.rootCA.cert }}
---
{{- end }}


{{/*
The below Certificate resource will trigger cert-manager to issue crt/key into Secrets.
These secrets are mounted into master/tserver pods.
*/}}
{{- range .Values.Services }}
{{- $service := . -}}
{{- $appLabelArgs := dict "label" .label "root" $root -}}
{{- $serviceValues := (dict "Service" $service "Values" $root.Values "Chart" $root.Chart "Release" $root.Release) -}}
{{- $replicas := (eq .name "yb-masters") | ternary $root.Values.replicas.master $root.Values.replicas.tserver -}}

{{- if (gt (int $replicas)  0) }}
---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: {{ $root.Values.oldNamingStyle | ternary (printf "%s-yugabyte-tls-cert" $service.label) (printf "%s-%s-tls-cert" (include "yugabyte.fullname" $root) $service.label) }}
  namespace: "{{ $root.Release.Namespace }}"
spec:
  secretTemplate:
    labels:
      {{- include "yugabyte.applabel" ($appLabelArgs) | indent 6 }}
      {{- include "yugabyte.labels" $root | indent 6 }}
  issuerRef:
    name:  {{ include "yugabyte.tls_cm_issuer" $root | quote }}
    {{- if $root.Values.tls.certManager.useClusterIssuer }}
    kind: ClusterIssuer
    {{- else }}
    kind: Issuer
    {{- end }}
  secretName: {{ $root.Values.oldNamingStyle | ternary (printf "%s-yugabyte-tls-cert" $service.label) (printf "%s-%s-tls-cert" (include "yugabyte.fullname" $root) $service.label) }}
  duration: {{ $root.Values.tls.certManager.certificates.duration | quote }}
  renewBefore: {{ $root.Values.tls.certManager.certificates.renewBefore | quote }}
  isCA: false
  privateKey:
    algorithm: {{ $root.Values.tls.certManager.certificates.algorithm | quote }}
    encoding: PKCS8
    size: {{ $root.Values.tls.certManager.certificates.keySize }}
    rotationPolicy: Always
  usages:
    - server auth
    - client auth
  # At least one of a DNS Name, URI, or IP address is required.
  dnsNames:
  {{- range $index := until ( int ( $replicas ) ) }}
  {{- $nodeOldStyle := printf "%s-%d.%s.%s.svc.%s" $service.label $index $service.name $root.Release.Namespace $root.Values.domainName }}
  {{- $nodeNewStyle := printf "%s-%s-%d.%s-%s.%s.svc.%s" (include "yugabyte.fullname" $root) $service.label $index (include "yugabyte.fullname" $root) $service.name $root.Release.Namespace $root.Values.domainName }}
  {{- $node := $root.Values.oldNamingStyle | ternary $nodeOldStyle $nodeNewStyle }}
  - {{$node}}
  {{- end }}
  - {{ printf "%s-%s.%s.svc.%s" (include "yugabyte.fullname" $root) $service.name $root.Release.Namespace $root.Values.domainName }}
  uris: []
  ipAddresses: []
---
{{- end }}
{{- end }}

---
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: {{ $root.Values.oldNamingStyle | ternary "yugabyte-tls-client-cert" (printf "%s-client-tls" (include "yugabyte.fullname" $root)) }}
  namespace: "{{ $root.Release.Namespace }}"
spec:
  secretTemplate:
    labels:
      {{- include "yugabyte.labels" $root | indent 6 }}
  issuerRef:
    name:  {{ include "yugabyte.tls_cm_issuer" $root | quote }}
    {{- if $root.Values.tls.certManager.useClusterIssuer }}
    kind: ClusterIssuer
    {{- else }}
    kind: Issuer
    {{- end }}
  secretName:  {{ $root.Values.oldNamingStyle | ternary "yugabyte-tls-client-cert" (printf "%s-client-tls" (include "yugabyte.fullname" $root)) }}
  duration: {{ $root.Values.tls.certManager.certificates.duration | quote }}
  renewBefore: {{ $root.Values.tls.certManager.certificates.renewBefore | quote }}
  commonName: yugabyte
  isCA: false
  privateKey:
    algorithm: {{ $root.Values.tls.certManager.certificates.algorithm | quote }}
    encoding: PKCS8
    size: {{ $root.Values.tls.certManager.certificates.keySize }}
    rotationPolicy: Always
  usages:
    - client auth
  dnsNames: []
  uris: []
  ipAddresses: []
---
{{- end }}
