# Checks whether the PC Secret follows the new JSON format for all auth types. Currently unused.
{{- define "isValidPCSecret" -}}
{{- $dataDict := . -}}
{{- if not (and (hasKey $dataDict "auth_type") (hasKey $dataDict "host") (hasKey $dataDict "port")) -}}
  false
{{- else if eq $dataDict.auth_type "basic-auth" -}}
  {{- if not (and (hasKey $dataDict "username") (hasKey $dataDict "password")) -}}
    false
  {{- else -}}
    true
  {{- end -}}
{{- else if eq $dataDict.auth_type "service-auth" -}}
  {{- if not (and (hasKey $dataDict "key_type") (hasKey $dataDict "key_value")) -}}
    false
  {{- else -}}
    true
  {{- end -}}
{{- else -}}
  false
{{- end -}}
{{- end -}}

# Checks whether the secret is a valid ServiceAuth secret in the new JSON format introduced with CSI 3.5
{{- define "isValidSASecret" -}}
{{- $dataDict := . -}}
{{- if not (and $dataDict.auth_type $dataDict.host $dataDict.port) -}}
  false
{{- else if eq $dataDict.auth_type "service-auth" -}}
  {{- if not (and $dataDict.key_type $dataDict.key_value) -}}
    false
  {{- else -}}
    true
  {{- end -}}
{{- else -}}
  false
{{- end -}}
{{- end -}}

# Check if the Secret uses the ip:port:username:password format (used in CSI < 3.5.0)
{{- define "isValidSecretKeyVal" -}}
{{- $input := . -}}
{{- $parts := split ":" $input -}}
{{- if not (eq (len $parts) 4) -}}
  false
{{- else -}}
  {{- $host := $parts._0 -}}
  {{- $port := $parts._1 -}}
  {{- $username := $parts._2 -}}
  {{- $password := $parts._3 -}}
  {{- if not (regexMatch "^[0-9]{1,5}$" $port) -}}
    false
  {{- else if or (eq $host "") (eq $username "") (eq $password "") -}}
    false
  {{- else -}}
    true
  {{- end -}}
{{- end -}}
{{- end -}}

{{- $usePC := .Values.ntnxInitConfigMap.usePC }}
{{- $createPrismCentralSecret := .Values.createPrismCentralSecret }}


# Validates the user defined PC secret
{{- if and (not $createPrismCentralSecret) $usePC }}
  {{- $releaseNamespace := .Release.Namespace }}
  {{- $releaseName := .Release.Name }}
  {{- $pcSecretName := .Values.pcSecretName }}
  {{- $pcSecret := lookup "v1" "Secret" $releaseNamespace $pcSecretName }}
  {{- if not $pcSecret }}
    {{- fail (printf "PC secret '%s' in namespace '%s' not found when usePC is set to true. Please create the secret before installing or upgrading the chart." $pcSecretName $releaseNamespace) }}
  {{- end }}
  {{- $dataDict := dict }}
  {{- range $pcSecretKey, $pcSecretDataEncoded := $pcSecret.data | default (dict) }}
    {{- $_ := set $dataDict $pcSecretKey ($pcSecretDataEncoded | b64dec | trim) }}
  {{- end }}
  {{- if include "isValidSASecret" $dataDict | eq "false" }}
    {{- if not (hasKey $dataDict "key") }}
      {{- fail (printf "PC secret '%s' in namespace '%s' does not follow the required schema. Please update the secret before installing or upgrading the chart." $pcSecretName $releaseNamespace) }}
    {{- end }}
    {{- $pcSecretKeyVal := $dataDict.key }}
    {{- if include "isValidSecretKeyVal" $pcSecretKeyVal | eq "false" }}
      {{- fail (printf "PC secret '%s' in namespace '%s' contains invalid secret value in field 'key'." $pcSecretName $releaseNamespace) }}
    {{- end }}
  {{- end }}
{{- end }}


{{- $csiDriverName := include "nutanix-csi-storage.drivername" . }}
{{- $releaseName := .Release.Name }}
{{- $releaseNamespace := .Release.Namespace }}
{{- $ntnxVolumes := "NutanixVolumes" }}
{{- $createSecret := .Values.createSecret }}
{{- $peSecretName := .Values.peSecretName }}

# Checks whether the PE Secret follows the new JSON format for all auth types. Currently unused.
{{- define "isValidPESecret" -}}
{{- $dataDict := . -}}
{{- if not (and (hasKey $dataDict "auth_type") (hasKey $dataDict "host") (hasKey $dataDict "port")) -}}
  false
{{- else if (eq $dataDict.auth_type "basic-auth") }}
  {{- if not (and (hasKey $dataDict "username") (hasKey $dataDict "password")) -}}
    false
  {{- else -}}
    true
  {{- end -}}
{{- else if (eq $dataDict.auth_type "cert-auth") -}}
  {{- if not (hasKey $dataDict "cert") -}}
    false
  {{- else -}}
    true
  {{- end -}}
{{- else -}}
  false
{{- end -}}
{{- end -}}


# Validates the user defined PE secrets
{{- if not $usePC }}
  {{- $peSecrets := dict }}
  {{- $newSecrets := list }}
  {{- $scSecretRefs := list "provisioner" "controller-publish" "node-publish" "controller-expand" }}
  {{- $storageClasses := lookup "storage.k8s.io/v1" "StorageClass" "" "" -}}
  {{- range $sc := $storageClasses.items }} 
    {{- $provisioner := $sc.provisioner }}
    {{- if eq $provisioner $csiDriverName }}
      {{- $isNutanixVolume := false }}
      {{- range $key, $value := $sc.parameters }}
        {{- if and (eq (lower $key) "storagetype") (eq $value $ntnxVolumes)}}
          {{- $isNutanixVolume = true }}
        {{- end }}
      {{- end }}
      # check if the StorageClass provisions block volumes (storageType: NutanixVolumes)
      {{- if $isNutanixVolume }}
        {{- range $secretRef := $scSecretRefs }}
          {{- $secretNameKey := (printf "csi.storage.k8s.io/%s-secret-name" $secretRef) }}
          {{- $secretNamespaceKey := (printf "csi.storage.k8s.io/%s-secret-namespace" $secretRef) }}
          {{- if not ( and (hasKey $sc.parameters $secretNameKey) (hasKey $sc.parameters $secretNamespaceKey)) }}
            {{- if not (eq $secretRef "controller-expand")}}
             {{- fail (printf "The upgrade or install failed due to missing parameters: '%s', '%s' in storage class: '%s'" $secretNameKey $secretNamespaceKey $sc.metadata.name) }}
            {{- end }}
          {{- else }}
            {{- $secretName := index $sc.parameters $secretNameKey }}
            {{- $secretNamespace := index $sc.parameters $secretNamespaceKey }}
            {{- if or (not $createSecret) (ne $secretName $peSecretName) (ne $secretNamespace $releaseNamespace)}}
              {{- $key := (printf "%s:%s:%s" $secretName $secretNamespace $sc.metadata.name) }}
              {{- if not (hasKey $peSecrets $key) }}
                # populate all the PE secrets in the cluster, referenced by the Block StorageClasses, into the $peSecrets dict
                {{- $_ := set $peSecrets $key true }}
              {{- end }}
            {{- end }}
          {{- end }}
        {{- end }}
      {{- end }}
    {{- end }}
  {{- end }}
  {{- range $key := keys $peSecrets }}
    {{- $parts := split ":" $key }}
    {{- $secretName := $parts._0 }}
    {{- $secretNamespace := $parts._1 }}
    {{- $scName := $parts._2 }}
    {{- $peSecret := lookup "v1" "Secret" $secretNamespace $secretName }}
    {{- if not $peSecret }}
      {{- fail (printf "PE secret '%s' in namespace '%s', referenced by StorageClass '%s', not found. Please create the secret before installing or upgrading the chart." $secretName $secretNamespace $scName) }}
    {{- end }}
    {{- $dataDict := dict }}
    {{- range $peSecretKey, $peSecretDataEncoded := $peSecret.data }}
      {{- $dataDict = merge $dataDict (dict $peSecretKey ($peSecretDataEncoded | b64dec | trim)) }}
    {{- end }}
    {{- if hasKey $dataDict "key"}}
      {{- $peSecretKeyVal := $dataDict.key }}
      # check if this is a valid basic auth secret
      {{- if include "isValidSecretKeyVal" $peSecretKeyVal | eq "false"}}
        {{- fail (printf "PE secret '%s' in namespace '%s' contains invalid secret value in field 'key'. Please update the secret before installing or upgrading the chart" $secretName $secretNamespace) }}
      {{- end }}
    {{- else }}
      # check if this is a cert based secret for MSP
      {{- if hasKey $dataDict "cert" }}
        {{- if not (and $dataDict.cert $dataDict.endpoint)}}
          {{- fail (printf "Invalid PE cert based secret '%s' in namespace '%s' Please update the secret before installing or upgrading the chart." $secretName $secretNamespace) }}
        {{- end }}
      {{- else }}
        {{- fail (printf "PE secret '%s' in namespace '%s' does not have the required 'key' field. Please update the secret before installing or upgrading the chart." $secretName $secretNamespace) }}
      {{- end }}
    {{- end }}
  {{- end }}
{{- end }}

